---
layout: post
title:  RX Java - Intro
date:   "2018-10-10 19:10:59"
author: eunkyung
categories: Software
tag: RX Java
cover:  "/assets/rxjava_image.png"
---

## 리액트 프로그래밍
리액트 프로그래밍이란 데이터가 변경되었을 때 연관되는 함수나 수식이 업데이트되는 방식을 말한다.
 - 명령형 프로그래밍 방식: 변경이 발생했다는 통지를 받아서 새로 계산을 당겨오는 방식 (pull 방식)
 - 리액트 프로그래밍 방식 : 데이터 소스가 변경된 데이터를 밀어주는 방식(옵저버 패턴과 비슷) (push 방식)
즉 내가 어떤 기능을 직접 실행하는 것이 아니라 시스템에 어떤 이벤트가 발생했을 때 처리하는 것(콜백이나 리스너 역시 리액티브 프로그래밍에 해당함.)

#### 함수형 프로그래밍과 콜백.옵저버 패턴의 차이
콜백이나 옵저버 패턴은 옵저버가 1개이거나 단일 스레드 환경에서는 문제가 없지만, 멀티 스레드 환경에서는 사용할 때 많은 주의가 필요함. (데드락, 동기화 문제 - 자바 병렬 프로그래밍)

그러나 함수형 프로그래밍은 부수효과(사이드 이팩트)가 없음. (부수효과 : 콜백이나 옵저버 패턴이 스레드에 안전하지 않은 이유는 같은 자원에 여러 스레드가 경쟁 조건에 빠지게 되었을 때 예측할 수 없는 잘못된 결과가 나오기 때문. 한두 개의 스레드가 있을 때 정상 동작을 하다가 수십 수백개의 스레드가 동시에 단일 자원에 접근하면 계산 결과가 꼬이고 디버깅하기가 매우 어려워진다.)

함수형 프로그래밍은 부수 효과가 없는 순수함수를 지향한다. 따라서 멀티 스레드에서도 안전하다. 

### -> 결론 및 요약 : 자바언어로 리액트 프로그래밍을 하기 위해서는 멀티스레드에서도 안전을 보장하는 함수형 프로그래밍을 사용하자.

베이스 소스를 정의할 수 있고 그것의 변경사항을 받아서 내 프로그램에 알려줄(push) 존재가 필요하다. 그것을 .NET 환경에서는 리액티브 확장이라고 하고 JVM 위의 자바 언얼 구현해 놓은 라이브러리가 RxJava이다.
 
#### RxJava를 만들게 된 이유
1. 자바의 동시성 처리를 하는데 번거로움이 있기 때문. -> 다수의 비동기 실행 흐름을 생성하고 제공됮 않았기 때문
2. 그당시 (2013년)에는 CompletableFuture 같은 클래스가 제공되지 않았기 때문. 그랫 비동기 흐름을 조합할 방법이 거의 없었다. -> 비동기 흐름을 조합(compose)할 수 있는 방법을 제공. RxJava에서는 조합하는 실행 단위를 리액티브 연산자(Operators)라고 함.
3. 콜백이 콜백을 부르느 콜백 지옥상황이 코드의 가독성을 떨어뜨리고 문제 발생시 디버깅을 어렵게 만들기 때문. 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계.

리액티브 프로그래밍은 비동기연산을 필터링, 변환, 조합해 위 세가지 핵심 이유를 해결 할 수 있다. RxJava는 Observable과 같은 데이터소스와 map(), filter(), reduce()와 같은 리액티브 연산자를 제공한다.

#### just() 함수
Observable 클래스의 just() 함수는 가장 단순한 Observable 선언 방식. Integer와 같은 래퍼 타입부터 Order같은 사용자 정의 클래스의 객체도 인자로 넣을 수 있다.

#### subscribe() 함수
subscribe() 함수는 Observable을 구독한다. Observable은 subscribe() 함수를 호출해야 비로소 변환한 데이터를 구독자에게 발행한다. (just함수만 호출하면 데이터를 발행하지 않음.) 옵저버패턴과 동일. 반드시 데이터를 수신할 구독자가 subscribe() 함수를 호출해야 Observable에서 데이터가 발행된다.

#### emit() 메서드
'어떤것을 보내다. 발행하다' 라는 뜻으로 개발자(사용자)가 만든 메서드. Observable이 subscribe() 함수를 호출한 구독자에게 데이터를 발행하는 것.

스레드 기반의 프로그래밍 -> 다수의 스레드를 활용하는 경우 사이드 이팩트 발생, 디버깅 어려움 -> 함수형프로그래밍 기법으로 스레드에 안전

```
1. Hot Observable, Cold Observable
2. map(), filter(), reduce(), flatMap()
3. 생성 연산자, 결합 연산자, 변환 연산자 등 카테고리별 주요 함수
4. 스케줄러의 의미. subscribeOn(), observeOn() 함수의 차이
5. 디버깅, 흐름 제어 함수
```

#### 마블다이어그램
- 실선 : 타임라인
- 도형 : 데이터 발행. onNext()
- 파이프(|) : 데이터발행 완료. onComplete()
- 아래점선화살표: 각각 함수의 입력과 출력
- 가운데 박스 : 함수
- 엑스(X) : 에러 발생. onError()
