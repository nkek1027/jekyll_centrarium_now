---
layout: post
title:  RX Java
date:   "2018-10-10 19:10:59"
author: eunkyung
categories: Software
tag: RX Java
cover:  "/assets/rxjava_image.png"
---

## 리액트 프로그래밍
리액트 프로그래밍이란 데이터가 변경되었을 때 연관되는 함수나 수식이 업데이트되는 방식을 말한다.
 - 명령형 프로그래밍 방식: 변경이 발생했다는 통지를 받아서 새로 계산을 당겨오는 방식 (pull 방식)
 - 리액트 프로그래밍 방식 : 데이터 소스가 변경된 데이터를 밀어주는 방식(옵저버 패턴과 비슷) (push 방식)
즉 내가 어떤 기능을 직접 실행하는 것이 아니라 시스템에 어떤 이벤트가 발생했을 때 처리하는 것(콜백이나 리스너 역시 리액티브 프로그래밍에 해당함.)

#### 함수형 프로그래밍과 콜백.옵저버 패턴의 차이
콜백이나 옵저버 패턴은 옵저버가 1개이거나 단일 스레드 환경에서는 문제가 없지만, 멀티 스레드 환경에서는 사용할 때 많은 주의가 필요함. (데드락, 동기화 문제 - 자바 병렬 프로그래밍)

그러나 함수형 프로그래밍은 부수효과(사이드 이팩트)가 없음. (부수효과 : 콜백이나 옵저버 패턴이 스레드에 안전하지 않은 이유는 같은 자원에 여러 스레드가 경쟁 조건에 빠지게 되었을 때 예측할 수 없는 잘못된 결과가 나오기 때문. 한두 개의 스레드가 있을 때 정상 동작을 하다가 수십 수백개의 스레드가 동시에 단일 자원에 접근하면 계산 결과가 꼬이고 디버깅하기가 매우 어려워진다.)

함수형 프로그래밍은 부수 효과가 없는 순수함수를 지향한다. 따라서 멀티 스레드에서도 안전하다. 

### -> 결론 및 요약 : 자바언어로 리액트 프로그래밍을 하기 위해서는 멀티스레드에서도 안전을 보장하는 함수형 프로그래밍을 사용하자.

베이스 소스를 정의할 수 있고 그것의 변경사항을 받아서 내 프로그램에 알려줄(push) 존재가 필요하다. 그것을 .NET 환경에서는 리액티브 확장이라고 하고 JVM 위의 자바 언얼 구현해 놓은 라이브러리가 RxJava이다.
 
#### RxJava르 만들게 된 이유
1. 자바의 동시성 처리를 하는데 번거로움이 있기 때문. -> 다수의 비동기 실행 흐름을 생성하고 제공됮 않았기 때문
2. 그당시 (2013년)에는 CompletableFuture 같은 클래스가 제공되지 않았기 때문. 그랫 비동기 흐름을 조합할 방법이 거의 없었다. -> 비동기 흐름을 조합(compose)할 수 있는 방법을 제공. RxJava에서는 조합하는 실행 단위를 리액티브 연산자(Operators)라고 함.
3. 콜백이 콜백을 부르느 콜백 지옥상황이 코드의 가독성을 떨어뜨리고 문제 발생시 디버깅을 어렵게 만들기 때문. 그래서 RxJava는 콜백을 사용하지 않는 방향으로 설계.

리액티브 프로그래밍은 비동기연산을 필터링, 변환, 조합해 위 세가지 핵심 이유를 해결 할 수 있다. RxJava는 Observable과 같은 데이터소스와 map(), filter(), reduce()와 같은 리액티브 연산자를 제공한다.
